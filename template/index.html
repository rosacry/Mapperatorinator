<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mapperatorinator Interface (Flask+pywebview)</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
<div id="flash-container"></div>
<div class="container">
    <main>
        <form id="inferenceForm" method="POST" class="card form-card">
            <!-- Config Section -->
            <fieldset>
                <legend>Config</legend>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button type="button" id="export-config-btn" class="browse-button">Export</button>
                    <input type="file" id="import-config-input" accept=".json" style="display: none;" />
                    <button type="button" id="import-config-btn" class="browse-button">Import</button>
                    <button type="button" id="reset-config-btn" class="browse-button">Clear</button>
                </div>
                <div id="config-status" style="margin-top: 10px; font-size: 14px;"></div>
            </fieldset>

            <!-- Paths Section -->
            <fieldset>
                <legend>Paths</legend>
                <div class="path-input-group">
                    <label for="audio_path" title="Path to audio file">Audio Path:</label>
                    <input type="text" id="audio_path" name="audio_path" />
                    <button type="button" class="browse-button" data-browse-type="file" data-target="audio_path">Browse...</button>
                </div>
                <div class="path-input-group">
                    <label for="output_path" title="Path to output folder">Output Path:</label>
                    <input type="text" id="output_path" name="output_path" />
                    <button type="button" class="browse-button" data-browse-type="folder" data-target="output_path">Browse...</button>
                </div>
                <div class="path-input-group">
                    <label for="beatmap_path" title="Path to .osu file to autofill metadata, audio path, and output path, or use as reference">Beatmap Path:</label>
                    <input type="text" id="beatmap_path" name="beatmap_path" />
                    <button type="button" class="browse-button" data-browse-type="file" data-target="beatmap_path">Browse...</button>
                </div>

                <!-- In-Context Options Box -->
                <div id="in-context-options-box" class="context-options-box" style="display: none;">
                    <h4 title="List of additional context to provide to the model">In-Context Options</h4>
                    <div class="context-options-container">
                        {% for option in [('TIMING', 'Timing'), ('KIAI', 'Kiai'), ('GD', 'Guest Difficulty'), ('NO_HS', 'No Hitsound')] %}
                        <div class="context-option-item" data-value="{{ option[0] }}">
                            <input type="checkbox" id="context-{{ option[0].lower() }}" name="in_context_options" value="{{ option[0] }}" />
                            <label for="context-{{ option[0].lower() }}">{{ option[1] }}</label>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </fieldset>

            <!-- Basic Settings -->
            <fieldset>
                <legend>Basic Settings</legend>
                <label for="model">Model:</label>
                <select id="model" name="model" class="styled-select">
                    <option value="v28">Mapperatorinator V28</option>
                    <option value="v29">Mapperatorinator V29 (Supports gamemodes and descriptors)</option>
                    <option value="v30" selected>Mapperatorinator V30 (Best model)</option>
                    <option value="v31">Mapperatorinator V31 (Slightly more accurate than V29)</option>
                </select>

                <label for="gamemode">Gamemode:</label>
                <select id="gamemode" name="gamemode" class="styled-select">
                    {% for mode in [('0', 'Standard'), ('1', 'Taiko'), ('2', 'Catch the Beat'), ('3', 'Mania')] %}
                    <option value="{{ mode[0] }}">{{ mode[1] }}</option>
                    {% endfor %}
                </select>

                <label for="difficulty" title="Difficulty rating (star rating)">Difficulty (star rating):</label>
                <input type="number" step="0.1" id="difficulty" name="difficulty" min="0" value="5" />
            </fieldset>

            <!-- Difficulty Metadata -->
            <fieldset>
                <legend>Difficulty Metadata</legend>
                <label for="hp_drain_rate" title="HP drain rate (HP)">HP Drain Rate (HP):</label>
                <input type="number" step="0.1" id="hp_drain_rate" name="hp_drain_rate" min="0" max="10" value="5" />

                <div class="form-group conditional-field" id="group-circle_size" data-show-for-gamemode="0" style="display: none;">
                    <label for="circle_size" title="Circle size (CS)">Circle Size (CS):</label>
                    <input type="number" step="0.1" id="circle_size" name="circle_size" min="0" max="10" value="4" />
                </div>

                <div class="form-group conditional-field" id="group-keycount" data-show-for-gamemode="3" style="display: none;">
                    <label for="keycount" title="Number of keys for mania">Key Count:</label>
                    <input type="number" id="keycount" name="keycount" min="0" max="18" value="4" />
                </div>

                <label for="overall_difficulty" title="Overall difficulty (OD)">Overall Difficulty (OD):</label>
                <input type="number" step="0.1" id="overall_difficulty" name="overall_difficulty" min="0" max="10" value="8" />

                <label for="approach_rate" title="Approach rate (AR)">Approach Rate (AR):</label>
                <input type="number" step="0.1" id="approach_rate" name="approach_rate" min="0" max="10" value="9" />

                <label for="slider_multiplier" title="Slider velocity multiplier">Slider Multiplier:</label>
                <input type="number" step="0.1" id="slider_multiplier" name="slider_multiplier" min="0" max="3.6" value="1.4" />

                <label for="slider_tick_rate" title="Slider tick rate">Slider Tick Rate:</label>
                <input type="number" step="0.5" id="slider_tick_rate" name="slider_tick_rate" min="0.5" max="4.0" value="1" />
            </fieldset>

            <!-- Advanced Settings -->
            <fieldset>
                <legend>Advanced Settings</legend>
                <label for="mapper_id" title="Mapper user ID for style">Mapper ID:</label>
                <input type="text" id="mapper_id" name="mapper_id" />

                <div class="form-group conditional-field" id="group-year" data-hide-for-model="v30">
                    <label for="year" title="Year of the song (2007-2023)">Year (2007-2023):</label>
                    <input type="number" id="year" name="year" min="2007" max="2023" value="2023" />
                </div>

                <div class="form-group conditional-field" id="group-hold_note_ratio" data-show-for-gamemode="3" style="display: none;">
                    <label for="hold_note_ratio" title="Hold note ratio for mania 0-1">Hold Note Ratio:</label>
                    <input type="number" step="0.01" id="hold_note_ratio" name="hold_note_ratio" min="0" max="1" />
                </div>

                <div class="form-group conditional-field" id="group-scroll_speed_ratio" data-show-for-gamemode="2,3" style="display: none;">
                    <label for="scroll_speed_ratio" title="Scroll speed ratio for mania and ctb 0-1">Scroll Speed Ratio:</label>
                    <input type="number" step="0.01" id="scroll_speed_ratio" name="scroll_speed_ratio" min="0" max="1" />
                </div>

                <label for="cfg_scale" title="Scale of the classifier-free guidance">CFG Scale:</label>
                <input type="number" step="0.1" id="cfg_scale" name="cfg_scale" min="0" value="1.0"/>

                <label for="temperature">Temperature:</label>
                <input type="number" id="temperature" name="temperature" step="0.01" min="0" max="1" value="0.9">

                <label for="top_p">Top-p:</label>
                <input type="number" id="top_p" name="top_p" step="0.01" min="0" max="1" value="0.9">

                <label for="seed" title="Random seed for generation">Random Seed:</label>
                <input type="text" id="seed" name="seed" />
            </fieldset>

            <!-- Generation Interval -->
            <fieldset>
                <legend>Generation Interval</legend>
                <label for="start_time" title="Generation start time in milliseconds">Start Time (ms):</label>
                <input type="number" id="start_time" name="start_time" min="0" />

                <label for="end_time" title="Generation end time in milliseconds">End Time (ms):</label>
                <input type="number" id="end_time" name="end_time" min="0" />
            </fieldset>

            <!-- Options -->
            <fieldset>
                <legend>Options</legend>
                <div class="option-item">
                    <input type="checkbox" id="export_osz" name="export_osz" value="false" />
                    <label for="export_osz" title="Whether to export a .osz file containing the generated beatmap and audio file">Export .osz</label>
                </div>

                <div class="option-item conditional-field" id="add-to-beatmap-option" style="display: none;">
                    <input type="checkbox" id="add_to_beatmap" name="add_to_beatmap" value="false" />
                    <label for="add_to_beatmap" title="Whether to add generated content to the reference beatmap instead of making a new beatmap">Add to Beatmap</label>
                </div>

                <div class="option-item conditional-field" id="option-item-hitsounded" data-hide-for-model="v30">
                    <input type="checkbox" id="hitsounded" name="hitsounded" value="true" checked />
                    <label for="hitsounded">Add Hitsounds</label>
                </div>

                <div class="option-item">
                    <input type="checkbox" id="super_timing" name="super_timing" value="false" />
                    <label for="super_timing" title="Whether to use slow accurate variable BPM timing generator">Super Timing</label>
                </div>
            </fieldset>

            <!-- Descriptors -->
            <div class="custom-dropdown-descriptors conditional-field" data-hide-for-model="v30">
                <div class="dropdown-header">
                    <div>
                        <span class="dropdown-title" title="List of descriptors for style (1 click = include, 2 clicks = exclude)">Descriptors</span>
                    </div>
                    <span class="dropdown-arrow">&#9660;</span>
                </div>
                <div class="dropdown-content">
                    <div class="descriptors-container">
                        {% set descriptor_groups = [
                        { "title": "General", "items": [
                        { "value": "gimmick", "title": "Focused on a single unique design or gameplay idea." },
                        { "value": "2B", "title": "Includes gameplay elements with two or more objects placed simultaneously." },
                        { "value": "slider only", "title": "Restricts object choice to sliders only." },
                        { "value": "circle only", "title": "Restricts object choice to circles only." },
                        { "value": "swing", "title": "Uses 1/3, 1/6, and 1/12 snap divisors for most/all objects." }
                        ]},
                        { "title": "Meta Information", "items": [
                        { "value": "collab", "title": "A map with two or more associated mappers." },
                        { "value": "megacollab", "title": "A map with 8 or more associated mappers." },
                        { "value": "marathon", "title": "A map with a drain time of over 5 minutes." },
                        { "value": "gungathon", "title": "A map with a drain time of over 10 minutes." },
                        { "value": "multi-song", "title": "Contains multiple songs within the audio." },
                        { "value": "variable timing", "title": "Contains multiple timing points, usually for non-metronome songs." },
                        { "value": "accelerating bpm", "title": "Features progressively increasing tempo." },
                        { "value": "time signatures", "title": "Many changes or uncommon time signatures." },
                        { "value": "storyboard", "title": "Contains a storyboard that enhances gameplay experience." },
                        { "value": "storyboard gimmick", "title": "Uses storyboard elements that change how the map is played." },
                        { "value": "keysounds", "title": "Uses various pitched hitsounds to create a melody." },
                        { "value": "download unavailable", "title": "Cannot be downloaded from the osu! website." },
                        { "value": "custom skin", "title": "Utilizes custom skin elements and graphics." },
                        { "value": "featured artist", "title": "Features song(s) from osu!'s Featured Artist listing." },
                        { "value": "custom song", "title": "Maps a song made specifically for the map." }
                        ]},
                        { "title": "Style", "items": [
                        { "value": "messy", "title": "Visually chaotic and disorganised patterns." },
                        { "value": "geometric", "title": "Incorporates geometric shapes within the design." },
                        { "value": "grid snap", "title": "Objects are placed along a square grid." },
                        { "value": "hexgrid", "title": "Objects are placed along a hexagonal grid." },
                        { "value": "freeform", "title": "A loose approach to visual structure." },
                        { "value": "symmetrical", "title": "Employs symmetry within the design." },
                        { "value": "old-style revival", "title": "Emulates a style from early mapping." },
                        { "value": "clean", "title": "Visually uncluttered and organised patterns." },
                        { "value": "slidershapes", "title": "Uses a variety of slider designs." },
                        { "value": "distance snapped", "title": "Uses osu's built-in distance snap feature." },
                        { "value": "iNiS-style", "title": "Originates from the original DS games." },
                        { "value": "avant-garde", "title": "Experimental design philosophies." },
                        { "value": "perfect stacks", "title": "Features perfectly overlapped stacked notes." },
                        { "value": "ninja spinners", "title": "Features very short spinners." }
                        ]},
                        { "title": "Song Representation", "items": [
                        { "value": "simple", "title": "Accessible and straightforward design." },
                        { "value": "chaotic", "title": "Unpredictable map design." },
                        { "value": "repetition", "title": "Features recognizable identical patterns." },
                        { "value": "progression", "title": "Gradual advancement in difficulty." },
                        { "value": "high contrast", "title": "Uses flashy ideas to follow music changes." },
                        { "value": "improvisation", "title": "Uses patterns that do not directly match the music." },
                        { "value": "playfield usage", "title": "Deliberate use of the playfield." },
                        { "value": "playfield constraint", "title": "Restricts object placement to a part of the playfield." },
                        { "value": "video gimmick", "title": "References the background video in its patterning." },
                        { "value": "difficulty spike", "title": "A sudden, significant challenge increase." },
                        { "value": "low sv", "title": "Prominent low slider velocity usage." },
                        { "value": "high sv", "title": "Prominent high slider velocity usage." },
                        { "value": "colorhax", "title": "Intentional use of combo colors for immersion." }
                        ]},
                        { "title": "Skillsets", "items": [
                        { "value": "tech", "title": "Tests uncommon skills." },
                        { "value": "slider tech", "title": "Tests skills involving complex sliders." },
                        { "value": "complex sv", "title": "Large changes in slider velocity to test reading." },
                        { "value": "reading", "title": "Tests a player's reading skill." },
                        { "value": "visually dense", "title": "Patterns with many visible notes that make reading hard." },
                        { "value": "overlap reading", "title": "Overlapped objects obscure note order." }
                        ]},
                        { "title": "Aim", "items": [
                        { "value": "jump aim", "title": "Focuses heavily on jumps." },
                        { "value": "sharp aim", "title": "Heavy use of sharp angle movement." },
                        { "value": "wide aim", "title": "Uses wide angle movement patterns." },
                        { "value": "linear aim", "title": "Requires continuous straight movement." },
                        { "value": "aim control", "title": "Features abrupt velocity or direction changes." },
                        { "value": "flow aim", "title": "Encourages fully continuous cursor movement." },
                        { "value": "precision", "title": "Requires fine, precise cursor movement." }
                        ]},
                        { "title": "Tap", "items": [
                        { "value": "finger control", "title": "Tests complex tapping ability." },
                        { "value": "complex snap divisors", "title": "Uses unusual snap divisors." },
                        { "value": "bursts", "title": "Continuous alternating patterns, typically 9 notes or less." },
                        { "value": "streams", "title": "Continuous alternating patterns, typically more than 9 notes." },
                        { "value": "spaced streams", "title": "Streams with large spacing between notes." },
                        { "value": "cutstreams", "title": "Streams with very uneven spacing." },
                        { "value": "stamina", "title": "Tests endurance over long periods." }
                        ]},
                        { "title": "Scene", "items": [
                        { "value": "aspire", "title": "Uses glitches for unique effects." },
                        { "value": "mapping contest", "title": "An entry for a mapping contest." },
                        { "value": "tournament custom", "title": "A custom map for a tournament." },
                        { "value": "tag", "title": "Designed for multiplayer tag mode." },
                        { "value": "port", "title": "Originally created for other media then imported." }
                        ]}
                        ] %}

                        {% for group in descriptor_groups %}
                        <div class="descriptor-group">
                            <h3>{{ group.title }}</h3>
                            {% for item in group["items"] %}
                            <div class="descriptor-item">
                                {% set item_id = "desc-" ~ item.value|replace(" ", "-") %}
                                <input type="checkbox" id="{{ item_id }}" name="descriptors" value="{{ item.value }}" />
                                <label for="{{ item_id }}" title="{{ item.title }}">{{ item.value }}</label>
                            </div>
                            {% endfor %}
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>

            <button type="submit">Run Inference</button>
        </form>

        <!-- Progress Output -->
        <div id="progress_output" class="card" style="margin-top:20px; display:none;">
            <h3>Progress</h3>
            <div id="init_message">Initializing process... This may take a moment.</div>
            <div id="progressTitle" style="font-weight:bold; padding-bottom:5px;"></div>
            <div id="progressBarContainer">
                <div id="progressBar"></div>
            </div>
            <div style="margin-top: 10px; text-align: center;">
                <button type="button" id="cancel-button" class="cancel-button" style="display:none;">Cancel</button>
            </div>
            <div id="beatmapLink" style="display:none; margin-top:10px;">
                <a id="beatmapLinkAnchor" href="#" target="_blank">Click Here to go to the created beatmap...</a>
            </div>
            <div id="errorLogLink" style="display:none; margin-top:10px;">
                <a id="errorLogLinkAnchor" href="#">See why... (opens error log)</a>
            </div>
        </div>
    </main>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.min.js"></script>
<script>
    $(document).ready(function() {
        // Application state and configuration
        const AppState = {
            evtSource: null,
            isCancelled: false,
            inferenceErrorOccurred: false,
            accumulatedErrorMessages: [],
            errorLogFilePath: null,
            animationSpeed: 300,

            modelCapabilities: {
                "v28": {},
                "v29": {},
                "v30": {
                    supportedGamemodes: ['0'],
                    supportsYear: false,
                    supportedInContextOptions: ['TIMING'],
                    hideHitsoundsOption: true,
                    supportsDescriptors: false,
                },
            }
        };

        // Utility functions
        const Utils = {
            showFlashMessage(message, type = 'success') {
                const flashContainer = $('#flash-container');
                const alertClass = type === 'success' ? 'alert success' :
                                 type === 'cancel-success' ? 'alert alert-cancel-success' :
                                 'alert error';
                const messageDiv = $(`<div class="${alertClass}">${message}</div>`);
                flashContainer.append(messageDiv);
                setTimeout(() => messageDiv.remove(), 5000);
            },

            smoothScroll(target, offset = 0) {
                $('html, body').animate({
                    scrollTop: $(target).offset().top + offset
                }, 500);
            },

            resetFormToDefaults() {
                $('#inferenceForm')[0].reset();

                // Set specific defaults
                const defaults = {
                    model: 'v30', gamemode: '0', difficulty: '5', hp_drain_rate: '5',
                    circle_size: '4', keycount: '4', overall_difficulty: '8',
                    approach_rate: '9', slider_multiplier: '1.4', slider_tick_rate: '1',
                    year: '2023', cfg_scale: '1.0', temperature: '0.9', top_p: '0.9'
                };

                Object.entries(defaults).forEach(([id, value]) => {
                    $(`#${id}`).val(value);
                });

                // Reset checkboxes
                $('#hitsounded').prop('checked', true);
                $('#export_osz, #add_to_beatmap, #super_timing').prop('checked', false);

                // Clear descriptors and context options
                $('input[name="descriptors"], input[name="in_context_options"]')
                    .removeClass('positive-check negative-check').prop('checked', false);

                // Clear paths and optional fields
                $('#audio_path, #output_path, #beatmap_path, #mapper_id, #seed, #start_time, #end_time, #hold_note_ratio, #scroll_speed_ratio').val('');
            }
        };

        // UI Manager for conditional visibility
        const UIManager = {
            updateConditionalFields() {
                const selectedGamemode = $("#gamemode").val();
                const selectedModel = $("#model").val();
                const beatmapPath = $('#beatmap_path').val().trim();

                // Handle gamemode-based visibility
                $('.conditional-field[data-show-for-gamemode]').each(function() {
                    const $field = $(this);
                    const supportedModes = $field.data('show-for-gamemode').toString().split(',');
                    const shouldShow = supportedModes.includes(selectedGamemode);

                    if (shouldShow && !$field.is(':visible')) {
                        $field.slideDown(AppState.animationSpeed);
                    } else if (!shouldShow && $field.is(':visible')) {
                        $field.slideUp(AppState.animationSpeed);
                    }
                });

                // Handle model-based visibility
                $('.conditional-field[data-hide-for-model]').each(function() {
                    const $field = $(this);
                    const hiddenModels = $field.data('hide-for-model').toString().split(',');
                    const shouldHide = hiddenModels.includes(selectedModel);

                    if (shouldHide && $field.is(':visible')) {
                        $field.slideUp(AppState.animationSpeed);
                    } else if (!shouldHide && !$field.is(':visible')) {
                        $field.slideDown(AppState.animationSpeed);
                    }
                });

                // Handle beatmap path dependent fields
                const shouldShowBeatmapFields = beatmapPath !== '';
                ['#in-context-options-box', '#add-to-beatmap-option'].forEach(selector => {
                    const $element = $(selector);
                    if (shouldShowBeatmapFields && !$element.is(':visible')) {
                        $element.fadeIn(AppState.animationSpeed);
                    } else if (!shouldShowBeatmapFields && $element.is(':visible')) {
                        $element.fadeOut(AppState.animationSpeed);
                        if (selector === '#add-to-beatmap-option') {
                            $('#add_to_beatmap').prop('checked', false);
                        }
                    }
                });
            },

            updateModelSettings() {
                const selectedModel = $("#model").val();
                const capabilities = AppState.modelCapabilities[selectedModel] || {};

                // Handle gamemode restrictions
                const $gamemodeSelect = $("#gamemode");
                if (selectedModel === "v30") {
                    $gamemodeSelect.val('0').prop('disabled', true);
                    $gamemodeSelect.find("option").each(function() {
                        $(this).prop('disabled', $(this).val() !== '0');
                    });
                } else {
                    $gamemodeSelect.prop('disabled', false);
                    $gamemodeSelect.find("option").prop('disabled', false);
                }

                // Handle in-context options
                const supportedContext = capabilities.supportedInContextOptions ||
                                       ['NONE', 'TIMING', 'KIAI', 'MAP', 'GD', 'NO_HS'];

                $('input[name="in_context_options"]').each(function() {
                    const $checkbox = $(this);
                    const value = $checkbox.val();
                    const $item = $checkbox.closest('.context-option-item');
                    const isSupported = supportedContext.includes(value);

                    $item.data('model-allowed', isSupported);
                    $checkbox.prop('disabled', !isSupported);

                    if (isSupported) {
                        $item.slideDown(AppState.animationSpeed);
                    } else {
                        $item.slideUp(AppState.animationSpeed);
                    }
                });

                // Handle hitsounds for V30
                if (capabilities.hideHitsoundsOption) {
                    $('#hitsounded').prop('checked', true);
                }

                this.updateConditionalFields();
            }
        };

        // File Browser Manager
        const FileBrowser = {
            init() {
                window.addEventListener('pywebviewready', () => {
                    console.log("pywebview API is ready.");
                    this.attachBrowseHandlers();
                });
            },

            attachBrowseHandlers() {
                $('.browse-button[data-browse-type]').click(async function() {
                    const browseType = $(this).data('browse-type');
                    const targetId = $(this).data('target');

                    try {
                        const path = browseType === 'folder' ?
                                    await window.pywebview.api.browse_folder() :
                                    await window.pywebview.api.browse_file();

                        if (path) {
                            $(`#${targetId}`).val(path).trigger('input');
                            console.log(`Selected ${browseType}:`, path);
                        }
                    } catch (error) {
                        console.error(`Error browsing for ${browseType}:`, error);
                        alert(`Could not browse for ${browseType}. Ensure the backend API is running.`);
                    }
                });
            }
        };

        // Descriptor Manager
        const DescriptorManager = {
            init() {
                this.attachDropdownHandler();
                this.attachDescriptorClickHandlers();
            },

            attachDropdownHandler() {
                $('.custom-dropdown-descriptors .dropdown-header').click(function() {
                    const $dropdown = $(this).parent();
                    $dropdown.toggleClass('open');
                    if ($dropdown.hasClass('open')) {
                        Utils.smoothScroll(this);
                    }
                });
            },

            attachDescriptorClickHandlers() {
                $('.descriptors-container').on('click', 'input[name="descriptors"]', function(e) {
                    e.preventDefault();
                    const $checkbox = $(this);

                    if (!$checkbox.prop('disabled')) {
                        if ($checkbox.hasClass('positive-check')) {
                            $checkbox.removeClass('positive-check').addClass('negative-check');
                        } else if ($checkbox.hasClass('negative-check')) {
                            $checkbox.removeClass('negative-check');
                            $checkbox.prop('checked', false);
                            return;
                        } else {
                            $checkbox.addClass('positive-check');
                        }
                        $checkbox.prop('checked', true);
                    }
                });
            }
        };

        // Configuration Manager
        const ConfigManager = {
            init() {
                $('#export-config-btn').click(() => this.exportConfiguration());
                $('#import-config-btn').click(() => $('#import-config-input').click());
                $('#reset-config-btn').click(() => this.resetToDefaults());
                $('#import-config-input').change((e) => this.handleFileImport(e));
            },

            exportConfiguration() {
                const config = this.buildConfigObject();

                if (window.pywebview?.api?.browse_folder) {
                    this.exportToFolder(config);
                } else {
                    this.fallbackDownload(config);
                }
            },

            buildConfigObject() {
                const config = {
                    version: "1.0",
                    timestamp: new Date().toISOString(),
                    settings: {},
                    descriptors: { positive: [], negative: [] },
                    inContextOptions: []
                };

                // Export form fields
                $('#inferenceForm').find('input, select, textarea').each(function() {
                    const $field = $(this);
                    const name = $field.attr('name');
                    const type = $field.attr('type');

                    if (name && type !== 'file') {
                        config.settings[name] = type === 'checkbox' ? $field.prop('checked') : $field.val();
                    }
                });

                // Export descriptors
                $('input[name="descriptors"]').each(function() {
                    const $checkbox = $(this);
                    const value = $checkbox.val();
                    if ($checkbox.hasClass('positive-check')) {
                        config.descriptors.positive.push(value);
                    } else if ($checkbox.hasClass('negative-check')) {
                        config.descriptors.negative.push(value);
                    }
                });

                // Export in-context options
                $('input[name="in_context_options"]:checked').each(function() {
                    config.inContextOptions.push($(this).val());
                });

                return config;
            },

            async exportToFolder(config) {
                try {
                    const folderPath = await window.pywebview.api.browse_folder();
                    if (!folderPath) {
                        this.showConfigStatus("Export cancelled by user", "error");
                        return;
                    }

                    const filename = `mapperatorinator-config-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;

                    $.ajax({
                        url: "/save_config",
                        method: "POST",
                        data: {
                            folder_path: folderPath,
                            filename: filename,
                            config_data: JSON.stringify(config, null, 2)
                        },
                        success: (response) => {
                            if (response.success) {
                                this.showConfigStatus(`Configuration exported successfully to: ${response.file_path}`, "success");
                            } else {
                                this.showConfigStatus(`Error saving config: ${response.error}`, "error");
                            }
                        },
                        error: () => {
                            this.showConfigStatus("Failed to save config to server. Using browser download instead.", "error");
                            this.fallbackDownload(config);
                        }
                    });
                } catch (error) {
                    console.error("Error selecting folder:", error);
                    this.fallbackDownload(config);
                }
            },

            fallbackDownload(config) {
                const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mapperatorinator-config-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.showConfigStatus("Configuration exported successfully (browser download)", "success");
            },

            resetToDefaults() {
                if (confirm("Are you sure you want to reset all settings to default values? This cannot be undone.")) {
                    Utils.resetFormToDefaults();
                    $("#model, #gamemode, #beatmap_path").trigger('change');
                    this.showConfigStatus("All settings reset to default values", "success");
                }
            },

            handleFileImport(e) {
                const file = e.target.files[0];
                if (!file) return;

                if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                    this.showConfigStatus("Please select a valid JSON configuration file.", "error");
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => this.importConfiguration(e.target.result);
                reader.readAsText(file);
                $(e.target).val(''); // Reset input
            },

            importConfiguration(content) {
                try {
                    const config = JSON.parse(content);
                    if (!config.version) {
                        throw new Error("Invalid configuration file format");
                    }

                    // Store current state
                    const currentBeatmapPath = $('#beatmap_path').val().trim();

                    // Import settings
                    if (config.settings) {
                        Object.entries(config.settings).forEach(([name, value]) => {
                            const $field = $(`[name="${name}"]`);
                            if ($field.length) {
                                if ($field.attr('type') === 'checkbox') {
                                    $field.prop('checked', value);
                                } else {
                                    $field.val(value);
                                }
                            }
                        });
                    }

                    // Import descriptors
                    $('input[name="descriptors"]').removeClass('positive-check negative-check').prop('checked', false);
                    if (config.descriptors) {
                        config.descriptors.positive?.forEach(value => {
                            $(`input[name="descriptors"][value="${value}"]`)
                                .addClass('positive-check').prop('checked', true);
                        });
                        config.descriptors.negative?.forEach(value => {
                            $(`input[name="descriptors"][value="${value}"]`)
                                .addClass('negative-check').prop('checked', true);
                        });
                    }

                    // Import in-context options
                    $('input[name="in_context_options"]').prop('checked', false);
                    config.inContextOptions?.forEach(value => {
                        $(`input[name="in_context_options"][value="${value}"]`).prop('checked', true);
                    });

                    // Trigger updates
                    $("#model, #gamemode").trigger('change');

                    const newBeatmapPath = $('#beatmap_path').val().trim();
                    if (newBeatmapPath !== currentBeatmapPath) {
                        $("#beatmap_path").trigger('input');
                    }

                    this.showConfigStatus(`Configuration imported successfully! (${config.timestamp || 'Unknown date'})`, "success");

                } catch (error) {
                    console.error("Error importing configuration:", error);
                    this.showConfigStatus(`Error importing configuration: ${error.message}`, "error");
                }
            },

            showConfigStatus(message, type) {
                const $status = $("#config-status");
                $status.text(message)
                       .css('color', type === 'success' ? '#28a745' : '#dc3545')
                       .fadeIn();
                setTimeout(() => $status.fadeOut(), 5000);
            }
        };

        // Inference Manager
        const InferenceManager = {
            init() {
                $('#inferenceForm').submit((e) => this.handleSubmit(e));
                $('#cancel-button').click(() => this.cancelInference());
            },

            handleSubmit(e) {
                e.preventDefault();

                if (!this.validateForm()) return;

                this.resetProgress();
                this.startInference();
            },

            validateForm() {
                const audioPath = $('#audio_path').val().trim();
                const beatmapPath = $('#beatmap_path').val().trim();
                const outputPath = $('#output_path').val().trim();

                if (!audioPath && !beatmapPath) {
                    Utils.smoothScroll(0);
                    Utils.showFlashMessage("Either 'Beatmap Path' or 'Audio Path' are required for running inference", 'error');
                    return false;
                }

                if (!outputPath && !beatmapPath) {
                    Utils.smoothScroll(0);
                    Utils.showFlashMessage("Either 'Output Path' or 'Beatmap Path' are required for running inference", 'error');
                    return false;
                }

                return true;
            },

            resetProgress() {
                $('#flash-container').empty();
                $("#progress_output").show();
                Utils.smoothScroll('#progress_output');

                $("#progressBarContainer, #progressTitle").show();
                $("#progressBar").css("width", "0%").removeClass('cancelled error');
                $("#beatmapLink, #errorLogLink").hide();
                $("#init_message").text("Initializing process... This may take a moment.").show();
                $("#progressTitle").text("").css('color', '');
                $("#cancel-button").hide().prop('disabled', false).text('Cancel');
                $("button[type='submit']").prop("disabled", true);

                AppState.inferenceErrorOccurred = false;
                AppState.accumulatedErrorMessages = [];
                AppState.isCancelled = false;

                if (AppState.evtSource) {
                    AppState.evtSource.close();
                    AppState.evtSource = null;
                }
            },

            buildFormData() {
                const formData = new FormData($("#inferenceForm")[0]);

                // Handle descriptors
                formData.delete('descriptors');
                const positiveDescriptors = [];
                const negativeDescriptors = [];

                $('input[name="descriptors"]').each(function() {
                    const $cb = $(this);
                    if ($cb.hasClass('positive-check')) {
                        positiveDescriptors.push($cb.val());
                    } else if ($cb.hasClass('negative-check')) {
                        negativeDescriptors.push($cb.val());
                    }
                });

                positiveDescriptors.forEach(val => formData.append('descriptors', val));
                negativeDescriptors.forEach(val => formData.append('negative_descriptors', val));

                // Ensure hitsounded for V30
                if ($("#model").val() === "v30" && !$("#option-item-hitsounded").is(':visible')) {
                    formData.set('hitsounded', 'true');
                }

                return formData;
            },

            startInference() {
                $.ajax({
                    url: "/start_inference",
                    method: "POST",
                    data: this.buildFormData(),
                    processData: false,
                    contentType: false,
                    success: () => {
                        $("#cancel-button").show();
                        this.connectToSSE();
                    },
                    error: (jqXHR, textStatus, errorThrown) => {
                        console.error("Failed to start inference:", textStatus, errorThrown);
                        alert("Failed to start inference process. Check backend console.");
                        $("button[type='submit']").prop("disabled", false);
                        $("#cancel-button").hide();
                        $("#progress_output").hide();
                    }
                });
            },

            connectToSSE() {
                console.log("Connecting to SSE stream...");
                AppState.evtSource = new EventSource("/stream_output");
                AppState.errorLogFilePath = null;

                AppState.evtSource.onmessage = (e) => this.handleSSEMessage(e);
                AppState.evtSource.onerror = (err) => this.handleSSEError(err);
                AppState.evtSource.addEventListener("error_log", (e) => {
                    AppState.errorLogFilePath = e.data;
                });
                AppState.evtSource.addEventListener("end", (e) => this.handleSSEEnd(e));
            },

            handleSSEMessage(e) {
                if ($("#init_message").is(":visible")) $("#init_message").hide();
                if (AppState.isCancelled) return;

                const messageData = e.data;
                const errorIndicators = [
                    "Traceback (most recent call last):", "Error executing job with overrides:",
                    "FileNotFoundError:", "Exception:", "Set the environment variable HYDRA_FULL_ERROR=1"
                ];

                const isErrorMessage = errorIndicators.some(indicator => messageData.includes(indicator));

                if (isErrorMessage && !AppState.inferenceErrorOccurred) {
                    AppState.inferenceErrorOccurred = true;
                    AppState.accumulatedErrorMessages.push(messageData);
                    $("#progressTitle").text("Error Detected").css('color', 'var(--accent-color)');
                    $("#progressBar").addClass('error');
                } else if (AppState.inferenceErrorOccurred) {
                    AppState.accumulatedErrorMessages.push(messageData);
                } else {
                    this.updateProgress(messageData);
                }
            },

            updateProgress(messageData) {
                // Update progress title based on message content
                const lowerCaseMessage = messageData.toLowerCase();
                const progressTitles = {
                    "generating timing": "Generating Timing",
                    "generating kiai": "Generating Kiai",
                    "generating map": "Generating Map",
                    "seq len": "Refining Positions"
                };

                Object.entries(progressTitles).forEach(([keyword, title]) => {
                    if (lowerCaseMessage.includes(keyword)) {
                        $("#progressTitle").text(title);
                    }
                });

                // Update progress bar
                const progressMatch = messageData.match(/^\s*(\d+)%\|/);
                if (progressMatch) {
                    const currentPercent = parseInt(progressMatch[1].trim(), 10);
                    if (!isNaN(currentPercent)) {
                        $("#progressBar").css("width", currentPercent + "%");
                    }
                }

                // Check for completion message
                if (messageData.includes("Generated beatmap saved to")) {
                    const parts = messageData.split("Generated beatmap saved to");
                    if (parts.length > 1) {
                        const fullPath = parts[1].trim().replace(/\\/g, "/");
                        const folderPath = fullPath.substring(0, fullPath.lastIndexOf("/"));

                        $("#beatmapLinkAnchor")
                            .attr("href", "#")
                            .text("Click here to open the folder containing your map.")
                            .off("click")
                            .on("click", (e) => {
                                e.preventDefault();
                                $.get("/open_folder", { folder: folderPath })
                                    .done(response => console.log("Open folder response:", response))
                                    .fail(() => alert("Failed to open folder via backend."));
                            });
                        $("#beatmapLink").show();
                    }
                }
            },

            handleSSEError(err) {
                console.error("EventSource failed:", err);
                if (AppState.evtSource) {
                    AppState.evtSource.close();
                    AppState.evtSource = null;
                }

                if (!AppState.isCancelled && !AppState.inferenceErrorOccurred) {
                    AppState.inferenceErrorOccurred = true;
                    AppState.accumulatedErrorMessages.push("Error: Connection to process stream lost.");
                    $("#progressTitle").text("Connection Error").css('color', 'var(--accent-color)');
                    $("#progressBar").addClass('error');
                    Utils.showFlashMessage("Error: Connection to process stream lost.", "error");
                }

                if (!AppState.isCancelled) {
                    $("button[type='submit']").prop("disabled", false);
                }
                $("#cancel-button").hide();
            },

            handleSSEEnd(e) {
                console.log("Received end event from server.", e.data);
                if (AppState.evtSource) {
                    AppState.evtSource.close();
                    AppState.evtSource = null;
                }

                if (AppState.isCancelled) {
                    $("#progressTitle, #progressBarContainer, #beatmapLink, #errorLogLink").hide();
                } else if (AppState.inferenceErrorOccurred) {
                    this.handleInferenceError();
                } else {
                    $("#progressTitle").show().text("Processing Complete").css('color', '');
                    $("#progressBarContainer").show();
                    $("#progressBar").css("width", "100%").removeClass('error');
                }

                $("button[type='submit']").prop("disabled", false);
                $("#cancel-button").hide();
                AppState.isCancelled = false;
                AppState.inferenceErrorOccurred = false;
                AppState.accumulatedErrorMessages = [];
            },

            handleInferenceError() {
                const fullErrorText = AppState.accumulatedErrorMessages.join("\\n");
                let specificError = "An error occurred during processing. Check console/logs.";

                if (fullErrorText.includes("FileNotFoundError:")) {
                    const fileNotFoundMatch = fullErrorText.match(/FileNotFoundError:.*? file (.*?) not found/);
                    specificError = fileNotFoundMatch?.[1] ?
                        `Error: File not found - ${fileNotFoundMatch[1].replace(/\\\\/g, '\\\\')}` :
                        "Error: A required file was not found.";
                } else if (fullErrorText.includes("HYDRA_FULL_ERROR=1")) {
                    specificError = "There was an error while creating the beatmap. Check console/logs for details.";
                } else if (fullErrorText.includes("Error executing job")) {
                    specificError = "There was an error starting or executing the generation task.";
                } else if (fullErrorText.includes("Connection to process stream lost")) {
                    specificError = "Error: Connection to the generation process was lost.";
                }

                Utils.showFlashMessage(specificError, "error");
                $("#progressTitle").text("Processing Failed").css('color', 'var(--accent-color)').show();
                $("#progressBar").css("width", "100%").addClass('error');
                $("#progressBarContainer").show();
                $("#beatmapLink").hide();

                if (AppState.errorLogFilePath) {
                    $("#errorLogLinkAnchor").off("click").on("click", (e) => {
                        e.preventDefault();
                        $.get("/open_log_file", { path: AppState.errorLogFilePath })
                            .done(response => console.log("Open log response:", response))
                            .fail(() => alert("Failed to open log file via backend."));
                    });
                    $("#errorLogLink").show();
                }
            },

            cancelInference() {
                const $cancelBtn = $("#cancel-button");
                $cancelBtn.prop('disabled', true).text('Cancelling...');

                $.ajax({
                    url: "/cancel_inference",
                    method: "POST",
                    success: () => {
                        AppState.isCancelled = true;
                        $("#progress_output").hide();
                        Utils.showFlashMessage("Inference cancelled successfully.", "cancel-success");
                    },
                    error: (jqXHR) => {
                        const errorMsg = jqXHR.responseJSON?.message || "Failed to send cancel request. Unknown error.";
                        Utils.showFlashMessage(errorMsg, "error");
                        $cancelBtn.prop('disabled', false).text('Cancel');
                    }
                });
            }
        };

        // Initialize all components
        function initializeApp() {
            // Initialize Select2
            $('.select2').select2({
                placeholder: "Select options",
                allowClear: true,
                dropdownCssClass: "select2-dropdown-dark",
                containerCssClass: "select2-container-dark"
            });

            // Ensure progress title div exists
            if (!$("#progressTitle").length) {
                $("#progress_output h3").after("<div id='progressTitle' style='font-weight:bold; padding-bottom:5px;'></div>");
            }

            // Initialize all managers
            FileBrowser.init();
            DescriptorManager.init();
            ConfigManager.init();
            InferenceManager.init();

            // Attach event handlers
            $("#model").on('change', () => UIManager.updateModelSettings());
            $("#gamemode").on('change', () => UIManager.updateConditionalFields());
            $("#beatmap_path").on('input', () => UIManager.updateConditionalFields());

            // Initial UI updates
            UIManager.updateModelSettings();
        }

        // Start the application
        initializeApp();
    });
</script>
</body>
</html>
